<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WebRTC Test</title>
  </head>
  <body>
    <h1>WebRTC Test</h1>

    <label for="connID">
      Enter Connection ID:
      <input type="number" name="connID" id="connID" placeholder="1234567890" inputmode="latin" size="15" maxlength="10"/>
    </label>

    <button id="connectButton" name="connectButton" class="buttonleft">Connect</button>
    <button id="disconnectButton"name="disconnectButton" class="buttonright" disabled>Disconnect</button>

    <div class="messagebox">
      <label for="message">
        Enter a message:
        <input type="text" name="message" id="message" placeholder="Message text" inputmode="latin" size="60" maxlength="120" disabled />
      </label>
      <button id="sendButton" name="sendButton" class="buttonright" disabled>Send</button>
    </div>

    <div class="messagebox" id="receive-box">
      <h2>Messages:</h2>
    </div>

    <script type="module">
      let connectButton = null;
      let disconnectButton = null;
      let sendButton = null;
      let messageInputBox = null;
      let receiveBox = null;

      let connectId = null;

      let addedRemoteICE = null;
      let remoteSDP = null
      let connID = null;
      let connected = null;
      let localConnection = null; // RTCPeerConnection for our "local" connection
      let sendChannel = null; // RTCDataChannel for the local (sender)


      function startup() {
        connectButton = document.getElementById("connectButton");
        disconnectButton = document.getElementById("disconnectButton");
        sendButton = document.getElementById("sendButton");
        messageInputBox = document.getElementById("message");
        receiveBox = document.getElementById("receive-box");
        connectId = document.getElementById("connID");
        addedRemoteICE = 0
        connected = false;

        // Set event listeners for user interface widgets

        connectButton.addEventListener("click", connectPeers, false);
        disconnectButton.addEventListener("click", disconnectPeers, false);
        sendButton.addEventListener("click", sendMessage, false);
      }

      async function connectPeers(){
        localConnection = new RTCPeerConnection();
        addedRemoteICE = 0;
        connected = false;
        if (connectId.value.trim() == ""){//Host Mode
          console.log("Host Mode");
          sendChannel = localConnection.createDataChannel("sendChannel");
          sendChannel.onmessage = handleReceiveMessage;
          sendChannel.onopen = handleSendChannelStatusChange;
          sendChannel.onclose = handleSendChannelStatusChange;

          localConnection.onicecandidate = async(e) => {
            if (e.candidate){
              console.log("genICE");
              await fetch('/api/v2/signaling/Conn/'+connID+'/updateData', {headers: {"dataType":"hostICE", "data": JSON.stringify(e.candidate)}});
            }
          }

          let offer = await localConnection.createOffer();
          let response = await fetch('/api/v2/signaling/newConn', {headers:{"SDP": JSON.stringify(offer)}});
          if (response.ok){
            await localConnection.setLocalDescription(offer);
            connID = await response.text()
            connectId.value = connID
          }
          else{
            console.error("Failed to get Connection ID");
            return;
          }

          while (!connected) {
            let response2 = await fetch('/api/v2/signaling/Conn/'+connID+'/getData');
            if (response2.ok){
              let data = await response2.json();
              if (data.answer != remoteSDP && data.answer != null){
                console.log("gotAns")
                remoteSDP = data.answer;
                await localConnection.setRemoteDescription(JSON.parse(data.answer));
              }

              if (data.hostICE.length != addedRemoteICE){
                let newICE = data.remoteICE.slice((data.remoteICE.length-addedRemoteICE)*-1);
                for (let i = 0; i < newICE.length; i++) {
                  console.log("gotICE");
                  await localConnection.addIceCandidate(JSON.parse(newICE[i])).catch(handleAddCandidateError);
                  addedRemoteICE ++;
                }
              }
            }
            else if (response2.status == 400 && connected){
              console.log("Connection success!")
            }
            else{
              console.error("Failed to get Connection Info");
            }

            await new Promise(resolve => setTimeout(resolve, 500));

          }

        }
        else{//Client Mode
          console.log("Client Mode");
          connID = connectId.value.trim();
          localConnection.ondatachannel = (event) => {
            sendChannel = event.channel;
            sendChannel.onmessage = handleReceiveMessage;
            sendChannel.onopen = handleSendChannelStatusChange;
            sendChannel.onclose = handleSendChannelStatusChange;
          }

          //let ans;

          localConnection.onicecandidate = async(e) => {
            if (e.candidate){
              console.log("genICE");
              await fetch('/api/v2/signaling/Conn/'+connID+'/updateData', {headers: {"dataType":"remoteICE", "data": JSON.stringify(e.candidate)}})
            }
          }

            while (!connected) {
              let response2 = await fetch('/api/v2/signaling/Conn/'+connID+'/getData');
              if (response2.ok){
                let data = await response2.json();
                //console.dir(data);
                if (data.offer != remoteSDP && data.offer != null){
                  console.log("gotOffer");
                  remoteSDP = data.offer;
                  await localConnection.setRemoteDescription(JSON.parse(data.offer));
                  let ans = await localConnection.createAnswer();
                  await localConnection.setLocalDescription(ans);
                  await fetch('/api/v2/signaling/Conn/'+connID+'/updateData', {headers: {"dataType":"answer", "data": JSON.stringify(ans)}}).catch(e => console.log(e));

                }
                if (data.hostICE.length != addedRemoteICE){
                  let newICE = data.hostICE.slice((data.hostICE.length-addedRemoteICE)*-1)
                  for (let i = 0; i < newICE.length; i++) {
                    console.log("gotICE");
                    await localConnection.addIceCandidate(JSON.parse(newICE[i])).catch(handleAddCandidateError);
                    addedRemoteICE ++;
                  }
                }
              }
              else if (response2.status == 400 && connected){
                console.log("Connection success!")
              }
              else{
                console.error("Failed to get Connection Info");
              }

              await new Promise(resolve => setTimeout(resolve, 500));
            }

        }

      }

      function handleReceiveMessage(data){
        const newDiv = document.createElement("div");
        const line = document.createElement("p");
        const lineLabel = document.createElement("strong");
        lineLabel.innerHTML = "Received: ";
        line.innerHTML = data.data;
        line.style = "display: inline"
        newDiv.appendChild(lineLabel);
        newDiv.appendChild(line);
        receiveBox.appendChild(newDiv);
      }


      /*function handleCreateDescriptionError(error) {
        console.log(`Unable to create an offer: ${error.toString()}`);
      }*/

      function handleAddCandidateError() {
        console.log("Oh noes! addICECandidate failed!");
      }


      async function handleSendChannelStatusChange(event) {
        if (sendChannel) {
          const state = sendChannel.readyState;
          console.log(`Send channel's status has changed to ${state}`);

          if (state === "open") {
            messageInputBox.disabled = false;
            messageInputBox.focus();
            sendButton.disabled = false;
            disconnectButton.disabled = false;
            connectButton.disabled = true;
            connected = true;
            await fetch('/api/v2/signaling/Conn/'+connID+'/delete');
          } else {
            messageInputBox.disabled = true;
            sendButton.disabled = true;
            connectButton.disabled = false;
            disconnectButton.disabled = true;
            connected = false;
          }
        }
      }

      function sendMessage() {
        const message = messageInputBox.value;

        sendChannel.send(message);

        const newDiv = document.createElement("div");
        const line = document.createElement("p");
        const lineLabel = document.createElement("strong");
        lineLabel.innerHTML = "Sent: ";
        line.innerHTML = message;
        line.style = "display: inline"
        newDiv.appendChild(lineLabel);
        newDiv.appendChild(line);
        receiveBox.appendChild(newDiv);


        messageInputBox.value = "";
        messageInputBox.focus();
      }


      function disconnectPeers() {
        // Close the RTCDataChannels if they're open.

        sendChannel.close();

        // Close the RTCPeerConnections

        localConnection.close();

        sendChannel = null;
        localConnection = null;

        // Update user interface elements

        connectButton.disabled = false;
        disconnectButton.disabled = true;
        sendButton.disabled = true;

        messageInputBox.value = "";
        messageInputBox.disabled = true;
      }

      startup();
    </script>
  </body>
</html>
